1、并发的问题：
         脏读，读取到被更改之前的数据
         不可重复读，多次读取发现数据不一致
         幻读，出现范围不一样的数据
         不可重复读主要是说数据的修改，幻读是数据的增加或删除

2、事务隔离级别：
         读未提交，读取到未提交的数据，如果事物回滚，数据是脏读，出现脏读
         不可重复读，不会读到未提交的数据，如果事物提交，数据是不一致的，出现不可重复读
         可重复读（锁行了），不会出现脏读和不可重复读，如果表被增加或删除了数据，出现了幻读
         串行化（锁表了），脏读、不可以重得读、可重复读、幻读都不会出现
         由于事务隔离级别越高，并发就越低，所以可以选用一个隔离低的级别，并针对程序里面具体事物进行手动加锁

3、mysql默认隔离级别：
         为Repeatable Read，是主从binlog STATEMENT格式的BUG，选用的
         这时可以使用row格式（推荐使用），因为当时没有row格式。把隔离级别改为Read Commited，并发和使用都好
         https://www.cnblogs.com/shoshana-kong/p/10516404.html

4、事务锁：
        悲观锁，强烈的独占和排他特性，悲观认为别会修改，只有数据库层提供的锁机制才能真正保证数据访问的排他性
        乐观锁，更新的时候基于版本对比是否更新成功
        X锁、排他锁，只能一个事务获取，取到锁的事务可写，其他只可读
        S锁、共享锁，可以多事务获取，唯一获取到锁的事务可写，其他只可读

4、innodb 之MVCC（多版本并发控制）：
     读-读，不存在任何问题
     读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等
     写-写，可能丢失更新（默认加X锁）
     读-写时用MVCC，大多数据库支持
     写-写时用OCC（乐观并发控制）innodb 不支持，需要显示的回滚
     原理：1）、undo日志中每行有二个隐藏字段（创建时的版本号和删除时的版本号）
               2）、只实用于RC和RR两隔离级
               3）、insert时创建时的版本号为当前事务ID
               4）、update时copy一条，原行删除时的版本号为当前事务ID，新增行创建版本号为当前事务ID
               5）、delete时删除时的版本号为当前事务ID
               6）、会有线程去删除标记的行
     读的时候会根据当前事务ID、创建时的版本号和删除时的版本号进行匹配读取
     更新时会直接加X锁

     总结：
     mvcc提高了读写并发性，RC、RR都在它的基础上，不同的是RC拿当前照数据，rr是拿之前的快照（解决不可重复读）
     RR在更新时会锁住更多行（调用gap lock），有时可能会锁住整个表，所以RR并发没有RC好
     select .... for update. 加X锁（排他锁，只能一个事务获取，取到锁的事务可写，其他只可读）
     select .... lock in share mode. 加S锁（共享锁，可以多事务获取，唯一获取到锁的事务可写，其他只可读）
     X、S锁都是悲观锁的一种实现，而MVCC是一种乐观锁
     所以PHP应用在代码加锁是一种不友好的模式，因为1、PHP不是JAVA这种多线程共享内存 2、应该加锁在数据库层而不是代码层
        数据库层加锁也不好，会增加数据库负担，应该借助redis
        并不推荐使用for update作为日常开发使用。而且，在平时开发和运维中，使用了for update却忘记提交，会引起很多锁表故障
        innodb是使用索引来加行锁的，而myisam不支持行锁
        
5、RC与RR比较
     RC(READ-COMMITTED)
        优势
            高并发低开销：半一致性读
            No gap lock； early unlock。死锁可能性更低
        劣势
            不支持statement binlog，binlog消耗更大
            No gap lock；no early unlock。数据一致性更差

     RR(REPEATABLE-READ)
        优势
            支持gap lock：statement binlog
            事务级快照读
        劣势
            并发冲突高，加锁冲突更为剧烈
            不支持半一致性读，不支持early unlock

     early unlock：update后会释放不符合where的行
     半一致性读  ：不是完全串行化，一致性降低
     gap lock     ：解决当前事务的幻读问题，除当前事务之外的幻读不解决
     
6、日志（日志先行）
     事务日志（特殊场景如断电等情况下的保证）
         redo log：重做日志，记录事物更新后的值（新值）；一个保证持久性、原子性；
                         找到有<提交>但没<结束>的日志直接写入日志记录的新值进行重做，最后加上<结束>
         undo log：恢复日志，事务开始之前，记录事物更新前的值（旧值）；保证一致性；
                          找到有<开始>但没<提交>的日志直接写入日志记录的旧值进行恢复，之后再加<回滚>
         innodb通过回滚日志undo将所有已完成并写入磁盘的未完成事务进行rollback，然后redo中的事务全部重新执行一遍即可恢复数据
         都是保证了幂等的
    二进制日志（binary log）
         每一个除查询外的操作都会记录日志，用于主从复制同步、数据恢复
         与undo的区别是，非意外<比如delete人为删除>的操作用它恢复，也是工程师能用的一种恢复数据的日志，undo是数据库自己用的
         与事务日志不一样，事务日志是存储引擎层即innodb产生的，它是数据库层产生的即任何引擎下都会产生该日志
