1、并发的问题：
         脏读，读取到被更改之前的数据
         不可重复读，多次读取发现数据不一致
         幻读，出现范围不一样的数据
         不可重复读主要是说数据的修改，幻读是数据的增加或删除

2、事务隔离级别：
         读未提交，读取到未提交的数据，如果事物回滚，数据是脏读，出现脏读
         不可重复读，不会读到未提交的数据，如果事物提交，数据是不一致的，出现不可重复读
         可重复读（锁行了），不会出现脏读和不可重复读，如果表被增加或删除了数据，出现了幻读
         串行化（锁表了），脏读、不可以重得读、可重复读、幻读都不会出现
         由于事务隔离级别越高，并发就越低，所以可以选用一个隔离低的级别，并针对程序里面具体事物进行手动加锁

3、mysql默认隔离级别：
         为Repeatable Read，是主从binlog STATEMENT格式的BUG，选用的
         这时可以使用row格式（推荐使用），因为当时没有row格式。把隔离级别改为Read Commited，并发和使用都好
         https://www.cnblogs.com/shoshana-kong/p/10516404.html

4、事务锁：
        悲观锁，强烈的独占和排他特性，悲观认为别会修改，只有数据库层提供的锁机制才能真正保证数据访问的排他性
        乐观锁，更新的时候基于版本对比是否更新成功
        X锁、排他锁，只能一个事务获取，取到锁的事务可写，其他只可读
        S锁、共享锁，可以多事务获取，唯一获取到锁的事务可写，其他只可读

4、innodb 之MVCC（多版本并发控制）：
     读-读，不存在任何问题
     读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等
     写-写，可能丢失更新（默认加X锁）
     读-写时用MVCC，大多数据库支持
     写-写时用OCC（乐观并发控制）innodb 不支持，需要显示的回滚
     原理：1）、每行有二个隐藏字段（创建时的版本号和删除时的版本号）
               2）、只实用于RC和RR两隔离级
               3）、insert时创建时的版本号为当前事务ID
               4）、update时copy一条，原行删除时的版本号为当前事务ID，新增行创建版本号为当前事务ID
               5）、delete时删除时的版本号为当前事务ID
               6）、会有线程去删除标记的行
     读的时候会根据当前事务ID、创建时的版本号和删除时的版本号进行匹配读取
     更新时会直接加X锁

     总结：
     mvcc提高了读写并发性，RC、RR都在它的基础上，不同的是RC拿当前照数据，rr是拿之前的快照（解决不可重复读）
     RR在更新时会锁住更多行（调用gap lock），有时可能会锁住整个表，所以RR并发没有RC好
     select .... for update. 加X锁（排他锁，只能一个事务获取，取到锁的事务可写，其他只可读）
     select .... lock in share mode. 加S锁（共享锁，可以多事务获取，唯一获取到锁的事务可写，其他只可读）
     X、S锁都是悲观锁的一种实现，而MVCC是一种乐观锁
     所以PHP应用在代码加锁是一种不友好的模式，因为1、PHP不是JAVA这种多线程共享内存 2、应该加锁在数据库层而不是代码层
        数据库层加锁也不好，会增加数据库负担，应该借助redis
