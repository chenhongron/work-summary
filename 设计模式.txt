设计模式
  首先抽象出每种模式的角色，然后面向接口编程，最后再考虑内聚与耦合

http://www.cnblogs.com/f-zhao/category/925278.html
http://www.cnblogs.com/zuoxiaolong/p/pattern26.html
https://blog.csdn.net/lovelion/article/details/17517213

1、简单工厂，根据一个样本让工厂生产产品，用if。缺点是每一次产品有变化就需要修改工厂

2、工厂方法，分离产品与工厂，当产品变化是增加工厂就可以，缺点是这样会有很多工厂出现

3、抽象工厂，分离产品方法、产品与工厂，当产品或产品方法有变化是增加工厂，缺点和工厂方法一样，是它的升级版

4、单列模式，使用static静态属性只被实例一次的特性。值得注意的是并发如果使用线程同步实现会问题，会有同步、jvm等问题

5、代理模式，静态代理和动态代理
   静态代理：代理类和被代理类同时实现接口，在代理类中扩充被代理类的方法，使用时调用代理类相应方法
             缺点，会产生很多代理类；一旦接口增加方法，代理类与被代理类都需要维护
   动态代理：使用JDK自带的API newProxyInstance()，或Cglib代理，具体方式对照spring aop
             相对静态优点，代理类可以不实现接口

6、适配器模式，类适配器、对象适配器、接口适配器
         类适配器是继承需要适配的类，然后调用相应方法；对象适配是注入需要适配的类
         接口适配是使用抽象类做中间件，这样实现类不用完全去实现接口中的方法
   与代理模式，一个代理后操作方法，一个只是适配后对方法的组合

7、装饰器模式，定义多个装饰器，每个装饰器实现需要装饰的接口，最后将后一个装饰器以注入的方式装饰到前一个装饰器
   与适配器模式，一个是适配接口，一个是添加功能，可以叠加

8、享元模式，

9、观察者模式，定义被观察者、观察者接口，实现被观察者（聚集观察者方法，循环通知观察者），实现观察者，最后调用
  
10、模板方法模式，定义抽象类，抽象方法，final的模板方法（里面依次调用抽象方法，搭建逻辑框架），实现类就可以直接调用模板方法实现该模式

11、策略模式， 定义策略接口，让不同策略实现接口，让具体策略注入定义的环境类，使用时调用环境类就可以实现算法的策略

12、迭代器模式，定义迭代接口、实现，定义聚集接口、实现；集合类使用的实现方式

13、命令模式，实现命令接收者、发布命令者、调用命令者，最后在使用时依次调用、注入3个角色