    构架模型：第一层客户端，非mysql所有，包括连接处理、授权、安全等
                    第二层mysql服务，查询解析、分析、优化、缓存、内置函数、存储过程、视图、触发器等
                    第三层存储引擎，数据存储、提取，与linux底层文件类似，使用API与服务层通信
    索引原理：
           （索引是在引擎层实现的）
           二叉数的查找性能好，左子数比根小，右子数比根大
           但是二叉数是可以自由的构建的，很容易会变成一个顺序查找的树
           引入平衡二叉数AVL，这样可以完全提供二叉数的性能
           但AVL要保持平衡性会付出很的代价，比如上百万阶级的树，对插入一个值需要的左右旋会很消耗IO
           引入B+tree树（多路搜索树），叶子节点存值，非叶子节点只存引用，所有值是按键值大小顺序存放
           B+tree利用磁盘预加载页的倍数，设置一个节点等一个页，每个节点只需1次IO可以完全载入
           索引也可能左右旋，但旋转次数少

     优化：
           count()，指定列会不统计null值的，要计算查询行用count(*)
           join，本质是一个嵌套查询，所以只需要在第二个join表建索引即可
           limit，表数据很多时，尽可能覆盖索引查找，如id>10000 limit 10，而不是limit 10000, 10
           not null，需要使用到索引的列不要设置null
           左值原则，索引的存储就是如姓名存储，即先根据姓顺序存再根据名，使用函数、区间查询也是一样，优化器不能识别
           select少列，客户端必须接收完服务器的数据传输才能断开
           查询缓存，now()、curent_date（）这种实时是不能缓存的；语句只要有一个空格不同都不能命中缓存
           字段类型越简单越好
           UNSIGED可以使正数的上线提高一倍
           schema的列不要太多，行缓冲编码过的列转换成行数据的代价高