进线程
通信：srocket、rpc等

存储器
分类：由高到低寄存器、主存、辅存（还有高速缓存、二级缓存等）
关系：程序要执行需要把指令和数据装入主存，再放入寄存器（速度和cpu相当）；辅存就是i/o磁盘，当主存没有时就去找，速度慢
分配：单一、固定、动态分配
? 动态分配算法：顺序搜索（等）、索引搜索（哈希等）、动态可重定位（紧凑重定位）
离散分配：分页、分段、段页式
? 区别是分页是系统决定，分段是用户行为
? 段页式先分段再分页
? 分页算法：逻辑地址a÷页面大小l，取整求得页号，取余求得页内地址（页号从0开始）
? 页表：页号映射到对应的块号上
? 地址变换机构：通过页表实现，如页内地址为100则内存物理地址就为100
? 分段算法：建立逻辑段号地址、段表（不建立块信息（相比分页）而获得基址、段长）；然后直接比较逻辑表和段表，其中会有越界情况，最后加上偏移量就得到

虚拟存储器
存储不够用在逻辑上实现让用户看起来存储够用
将部分进程装入内存
实现方式：分页、分段管理方式
? 硬件支持：页/段表、中断机构、地址变换机构

i/o
设备上抽象的一层
分层：用户层软件、设备独立软件、驱动程序、中断处理程序、硬件
接口：块设备接口、流设备接口、网路设备接口
设备控制器：cpu与设备的接口
io通道：承担原cpu的任务，把cup在繁杂的任务中解救出来
? 类型：字节多路、数组选择、数组多路通道
io缓存

文件管理
os对数据抽象的一层
分为数据项、记录、文件
文件名，类型
层次：对象及其属性、对对象操作管理、接口（命令和程序接口）

补：
   1、如果内存不足，操作系统会把进程置换到存储设备中
   2、存储设备提供状态、命令、存储寄存器，操作系统的交互就是操作这三个。
       不会轮训状态寄存器，是使用中断，这样cpu可以空闲出来给其他进程用
   3、操作系统也是使用异常控制流做出反应的，比如中断，陷阱，故障和终止
   4、应用程序通过系统posix通知操作系统在内核态调用文件系统再调用设备接口最后调用设备驱动，以实现io
   5、文件系统重要的inode（index node）保存文件的大小，类型，块信息，时间信息等，用一个唯一id引用
        inode其实是一个索引表，减少了用链表表示时随机查找的慢问题；目录也是一样由inode组成的
   6、磁盘基本单位为扇区（512字节），所以磁盘制造商能保证512个字节即一个扇区的原子性。而操作系统是以块为单位的，现代操作系统都是以4kb为一个块
   7、操作系统对内存虚拟化的抽象叫地址空间（包括代码、栈、堆部分）。每个进程都有一个地址空间
   8、进程与线程，线程切换地址空间不变（页表不切换），且地址空间是多个栈
   9、还有一个操作系统的磁盘引导块
   10、操作系统管理计划文件存储的逻辑，系统操作cpu，cpu操作内存，内存操作硬盘，硬盘再通过区块，扇区，寻到，有旋转，读取内容。
    有人要读取? /tmp/test.log? 这个文件，查找次序是这样的：根目录inode->根目录磁盘块->tmp目录inode->tmp目录磁盘块->test.log的 inode->读取磁盘块
   11、中断分硬中断和软中断，中断是通过外部设备给 CPU 的 INTR 引脚发信号，异常是 CPU 自己执行指令的时候发现特殊情况触发的，自己给自己一个中断号
       前面2是硬中断，软中断是直接给 CPU 一个中断号 n，比如触发了 Linux 的系统调用，这种软件发出的中断