1、public private protected final static 类属性控制尽可能使用private私有，这样更符合OOP规范--类的封装。因为使用public，可以$class->a="123"进行直接附值，从而属性不可控

2、当private定义属性只能在当前类中使用时，可以用魔术方法__set() __get()在外部进行设置和获取类中的属性，这不是有点矛盾吗？其实是PHP语言在设计初就是为了快速开发、灵活、资源占用少的，使用魔术方法并不违背类的封装，同时又少去private的繁琐，所以是值得的

3、-> 类对象的引用   :: 静态类的引用    parent:: 重载类对象   self:: 静态属性和方法的内部引用  类名+:: 静态属性和方法的外部引用

4、__autoload()魔术函数 在实例化类时不存在加载，这里就有两个问题，类名和类文件路径，最流行的方式就是像Main_Super_Class一起加载类名和类文件路径;有了__autoload()可以不用大量的include_once(),还可以使用spl_autoload_register()自定义__autoload()，定义多个

5、接口和抽象类，1 接口只定义方法不实该方法，抽象类可以实现  2 可以实现多个接口但不能扩展多个抽象类  3 子类的权限都一样或更为宽松
	           4 接口方法只有public权限，抽象类可以是其他权限  5 抽象类未实现方法体必须申明abstract，反之不能申明  6 都不能被实例化

面向对象弊端：1、实际世界是多纬度的，属性和类别不好区分。红苹果是 color 属性为 red 的苹果，还是 Apple 的子类？
              2、面向对象编程有很多用途，很多用法，但是我们会发现「设计模式驱动」成为了非常有代表性的流派。有时我们会疑惑，为什么会有设计模式，为什么面向对象编程会出现如此恐怖的这么复杂的类关系。
              3、这个世界的天生属性，就是从不同的角度去看，就会有不同的风景。面向对象就是一种视角，去描述和抽象现实世界。
              4、过度封装而降低性能
              5、间接的导致一些程序员对继承的滥用

6、硬盘读写：
根据磁盘单次IO操作的过程，可以发现：
单次IO时间 = 寻道时间 + 旋转延迟 + 传送时间

进而推算IOPS(IO per second)的公式为：
IOPS = 1000ms/单次IO时间

以此推算出平均值为200。即一个硬盘平均支持200并发，那程序设计需要支持的上千并发呢，是由数据库集成做的，加忘记了硬盘缓存，这也提高了并发

7、对需要优化的表，数据大一般是3000W建议表分区 。。。ENGINE=Innodb PARTITION BY HASH(id DIV 1000000);
原理是物理上实现区化有序

8、MySQL日志：
错误日志：              记录错误
查询日志：              记录CURD的操作，开启增加I/O影响MYSQL性能
慢查询日志：            那些语句在查询上耗时长于规定时长，一般用于测试和数据库优化
事务日志（预写式日志）：默认开启，先将每条数据以顺序化修改其内存拷贝，在配制的时间后再一起写入磁盘持久化，大大提高性能，支持事件的引擎可用
二进制日志：            修改数据或有可能引起数据改变的语句

9、堆和栈
堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时 动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。

栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类 型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。

栈是由编译器自动分配和消除的，如变量、函数等，计算机请求
堆是由new分配的内存块，如new、delete操作等，用户请求

PHP中堆栈操作主要是:array_push()、array_pop()、array_shift()和array_unshift()

10、网络七层协议
    应用层    （应用软件）
    表示层    （定义数据格式及加密） 
    会话层    （双向会话的控制和管理，保证会话有序可靠，如交警）
    传输层    （TCP、UDP等协议）
    网络层    （IP、路由。寻址这类的底层）
    数据链路层（MAC地址，比如计算机传数据，先找到目标IP然后找到MAC，IP和MAC是绑定的。很底层）
    物理层    （连接头、帧、电流。直接底层）

11、架构
    抽离表现层           （V层分离，让M和C层重用）
    应用程序（域）逻辑分离(M和C层分离，让M层重用)
    布局分离		  (V层布局分离，最明显的是使用Twig模板引擎)
    前端控制器            (完成一些初始化、共同的前置事情)

12、mysql schema优化
    1、设置字段类型越简单越好，比如数字型代替字符串型
    2、尽量使用not null ，mysql保存空需要更多的开销。其他不是很明显，但在使用索引的时候相对明显
    3、在存储实数时，为保证小数的精准，可使用DECIMAL数据类型，但空间占用大，可以用BIGINT，剩以百万取整这样
    4、varchar与char,char是定长存储，适合比如md5码。比varchar快，不需要专门记录长度和定长不容易产生碎片
    5、使用枚举代替字符串，枚举很紧凑，在关联查询快
    6、使用TIMESTAMP代替DATETIME ，TIMESTAMP范围少，在2038年，所以比DATETIME快

    7、列尽量少，这个是MYSQL将行缓冲编码过的列转换成行数据的代价
    8、关联越少越少，尽可能在12张表以下，EVA设计是不好的

13、B-Tree数据结构
    每一个叶子节点都包含下一个叶子节点的指针，从而方便叶子节点的范围遍历

14、MYSQL索引
    1、索引在引擎层实现的
    2、索引使用B-Tree数据结构，所以适用大多的where和order by 、group by
    B-Tree多列索引：
    3、如果不是按照索引的最左列开始查找，则无法使用索引
    4、不能跳过索引中的列，跳过后只有索引最左被使用了
    5、如果索引中有某个列的范围查询，则其右边列都无法使用索引
    哈希索引：
    6、只有memory引擎才支持，只用于精确匹配查询。InnoDB引擎在某些索引使用频繁时会自动创建
    空间索引：MyISAM支持
    全文索引：
    主要用的英文上，以空格分词。不实用中文，需要分词
    7、索引列是表达式的一部分或者是函数的参数，都不能用到索引
    前缀索引：
    8、当查询的文本长时使用，COUNT(DISTINCT(LEFT(userid,6))) / COUNT(*)计算出越接近1越好。但不能用于group by 和order by 
       ALTER TABLE table_name ADD KEY(column_name(prefix_length));

15、树
    1、树      ：根节点、叶节点、父节点、子节点、边、子树和空树；树和深度、层；懒惰删除
    2、二叉树  ：左边全小，右边全大
    3、红黑树  ：颜色属性 
    4、B-tree  ：平衡树，叶节点指向数据；内节点存储有序的key、data并指向子节点
    5、B+tree  ：B-tree的变种；内节点不存储data，只存储key；叶子节点不存储指针

16、视图和存储过程

    视图：1、可以简化查询
          2、可以进行权限控制     （把表的权限封闭,但是开放相应的视图权限,视图里只开放部分数据）
          //3、大数据分表时可以用到 （表的行数超过200万行时,就会变慢,可以把一张的表的数据拆成4张表来存放）
    存储过程：
          1、用if/else, case,while等控制结构，可以进行sql编程

17、trait与多继承
    trait兼容面向对象聚合复用原则，形成多态
    trait申明的类才能适用于这种方式

18、一个简单的设计模式学习博客
    http://blog.csdn.net/u010825142/article/category/1429719
    http://blog.csdn.net/fireball1975/article/details/12996543  //UML

19、依赖与引用
    引用：该类不调用另外一个类的方法，而是将另外一个类的引用暴露出来，供外部调用;该类的具体业务实现不受另类的影响
    依赖：该类的具体业务受另类的影响，依赖于另一个类的实现

20、PHP规范（PSR）
    https://psr.phphub.org

21、PHP反射
    使用提供的反射API导出或提取出关于类、方法、属性、参数等的详细信息，如人照镜子反映人的影像

22、匿名函数与闭包
    匿名函数: 没有函数名，返回给一个变量用
    闭包    : 将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包
    匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字

23、反射与服务容器
    使用：如果服务是回调函数和无参类，可以不使用反射
          服务是有参类，则需要使用反射；因为不能确定类参数的数量，newInstanceArgs()可以统一传数组解决

24、编码
    1字节=8位  ：数字、大小写字母和常用符号7个位可以满足，多了浪费空间，刚好7位也不好，就用了8位
    ACSII编码  ：1字节8位编码完所有数字、大小写字母和常用符号,满足美国需要
    unicode编码：ACSII编码的扩充，但比较浪费储存空间，且分不清支持所有语言;对字符集数字化
    GB2312编码 ：简体中文编码，一个中文占2个字符，只支持简体中文
    utf8编码   ：unicode编码的一种实现，比较省储存空间,支持所有语言;好的存储和传输
                 如果一个字节的第一位是0，则这个字节单独就是一个字符
                 如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节
    utf16编码  ：utf8编码基础上支持更大，比如支持中国的满文、藏文等,支持所有语言

25、DAO架构模式
    直接操作数据库的一层，分离业务层和数据库，主要在JAVA中使用
    主要有server(controller)、service(business|DAO Factory)、DAO和veiw
    php的架构模式：controller、business(service)、model(DAO)和veiw；DAO层PHP没直接关系,DAO层存在就有service、DAO Factory概念

26、iaas、paas与saas云
    iaas基础设施即服务;如硬件服务器租用、阿里云
    paas是面向软件开发者的服务；如阿里云、又拍云
    saas是面向软件消费者的服务；如阿里云、又拍云中的某个产品

27、http cache
    强制缓存：Cache-Control设置max-age强制过了某时间后浏览器再请求服务器
    对比缓存：Cache-Control为no-cache；浏览器发送请求对比服务器，只是header的对比，不包含body体

28、聚合复用
    服务容器本质上是实现的聚合复用原则，也是这一原则的最大体现

29、PHP分别在apache、nginx上运行
    windows下，使用php-cgi，每一次请求创建一个PHP进程序，结束后回收，对内存开销很大
    linux下，在php5.3后的版本都可实现php-fmp，nginx可让进程常驻，由一个master主进程管理，其他worker
    apache是把php so通过php_modle模块加载到它的进程里
    nginx是静态把请求转发到php进程上处理

30、SOA、restFull、SOAP和RPC
    SOA      面向服务架设，具体实现方式是SOAP和RPC
    restFull 基于http协议API接口调用
    SOAP     老式的SOA实现XML
    RPC      新式的SOA实现，现有框架Yar、phalcon等

31、一个WEB请求在OSI中的流程
    WEB一般是4层协议：应用层、传输层、网络层和物理层
    浏览器根据域名-》DNS寻IP地址                     （DNS）
    浏览器得到IP地址通过HTTP协议封装信息             （应用层）
    封装后的HTTP包通过TCP协议三次握手、拆分、传输信息（传输层）
    传输的信息通过IP网际协议中转等去向客户端         （网络层）
    最后是客户端TCP合并信息、MAC、IP地址、网卡等呈现 （物理层）
    