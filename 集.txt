高低耦合：程序模块之间的关联、依赖。

尽量低耦合，实现低耦合过多运用接口（interface）,代表框架有ZF，TP

高耦合在实现逻辑流程上更得心应手，代表框架OpenBiz

面向对象三特性：封装、继承、多态
封装：抽象封装成类
继承：子类继承父类的功能
多态：子类对父类的不同表现；实现方式主要是重载、重写和接口


设计模式：

工厂模式  ：在工厂类中使用new,好处是调用工厂避免直接调用原始类，因为如果项目需要调用其它原始类时，可以新建一个类用工厂生产出，这样就不用直接更改原始类了，更改原始类往往会形成级联反应

单例模式：使用静态变量只被初始化一次的特性，对多个调用，单一返回;如果用到多线程还得注意线程安全；分布式系统有问题的不太好用

观察者模式：可以一次注册多个观察者（也可以一次注册一个，不用循环类），当事件有变化后可以foreach执行观察者事件

命令链模式：可以一次添加多个命令（也可以只添加一个，不用循环类），当访问请求时可以foreach每个处理程序会自行判断自己能否处理请求,和观察者模式很像(观察者是全部执行，命令链是选择执行,写框架扩展好)

策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换（多接口的继承。在依赖倒置原则的基础上，可以让某些继承的类，策略性的继承其他接口，这样就避免了可以让某些不实现该方法的类去继承其他接口，其他接口不需要实现）

代理模式：引用并扩展被代理的类，达到单一职责原则、细化类

适配模式：对老类不是直接修改而是以接口实现和继承到新类上面,适应开闭原则，常用在新版本对旧版本代码的兼容上


消息队列：一般是本机不同进程间通信用，当并发很高对于数据准确性要求不高时使用

静态类  ：当一个类有静态方法，这个类就是静态类；静态类可以不用实例化；并是在编译时加载到内存的，普通类动态加载到内存的；所以单次使用静态类和普通类没什么快慢区别，多次就静态类快了

静态变量：仅在局部函数域中存在且只被初始化一次,当程序执行离开此作用域时，其值不会消失,会使用上次执行的结果。可对值操作

ORM：面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。


设计原则:
1、 开闭原则          (需求改变时尽量少直接修改类,以继承、多态等修改子类。避免维护的增加。以下几个原则服务于些原则。对扩展开放对修改关闭)
2、 里氏替换原则    (尽量使用精准的抽象类或者接口,子类可以在任何地方替换它的父类；现实生活中正方形是特殊的长方形，但面向对象不能设计正方形是长方形的子类，因为替换不了父类，应该抽象出一个四边形基类；
      所以尽量不要对父类使用重写、重载，而是独立方法；要避免重写父类的非抽象方法，而多态的实现是通过重写抽象方法实现的)，所有引用基类的地方必须透明的使用其子类的对象
3、 单一职责原则    (类越小越好，比喻：点比直线画图好，至少直线不能画圆)
4、 接口隔离原则    (拆分，从接口开始，污染了接口其子类必污染。接口多重继承，按需给接口。客户端不应该依赖它不需要的接口,类间的依赖关系应该建立在最小的接口上；让类实现多个接口，而不是全归纳在一个接口然后去实现)
5、 依赖倒置原则    (面向抽象编程，解耦调用和被调用者.高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象。抽象不应该依赖于具体，具体应该依赖于抽象。
      只有说有人写对象时不依赖接口而是依赖于另一个对象，当第三个对象与依赖这个对象时，第一个对象可能会有第三个对象的功能，这样就是有问题的。其实应该在依赖上加接口，让它们都依赖于接口)
6、 迪米特原则       (不和陌生人说话，有事去找中介。尽量封装,不让调用者知道内部结构；如果一个方法放在本类中,即不增加类间关系，也对本类不产生负面影响就放在本类中；一个类只与他朋友类进行交互；朋友间也是有距离的)
7、 聚合复用原则  （聚合其他类中的方法完成功能，尽量少用继承，因为基类如果被修改，子类很容易出错。可以实现多态。注入其他类实现）

补充：1、找到系统中变化的部分，将变化的部分同其它稳定的部分隔开 2、面向接口编程，而不要面向实现编程
单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。

1、开闭原则
    一个软件实体如类，模块和函数应该对扩展开放，对修改关闭
    开闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改现有代码来完成变化

2、里氏替换原则
    父类用到的地方都可以用子类替换，反之未必

    继承优点是oop的3大特性，代码复用，提高扩展性
    缺点是继承是入侵的，子类一旦继承会有受约束，子类拥有个性后与父类难以调和

    为了避免缺点提高优点，引入里氏替换
    子类完全实现父类的抽象方法，但不能重写非抽象方法
    子类可以自己的个性新方法
    子类要重写父类方法时入参要同等或扩大
    子类要重写父类方法时出参要同等或缩小

3、单一职责原则
    类的职责尽量单一，但单一也要适度

4、接口隔离原则
    尽量多接口让其实现

5、依赖倒置原则
    依赖与抽象而不是实现， 高层模块不应该依赖低层模块，两都应该依赖于抽象
    实现是不稳定易变的，抽象是相对稳定不易变的

6、迪米特原则
    只与朋友类交流
    朋友类间也是要有距离
    是自己的就是自己的


接口与依赖倒置，工厂模式与策略模式
接口的好处：（1）一种规范（明文规定一种标准，写死的）（2）代码更加清晰（3）因为规范是写死的，使用后不用重复造轮子，即new。减少代码量复杂度、易扩展、清晰、健壮 。像插孔的使用
             (4)可以在未实现具体时其他方法调用，多成员同步开发（5）规范其他实现类，进行注入时实现多态
依赖倒置  ： 即使用接口，让低层类依赖接口高层类实现接口，保证低层类改变时不影响高层类
工厂模式  ： 即生产统一接口下的类，随需求的改变而改变生产
策略模式  ： 像工厂的升级，在工厂不能满足需求时，使用多个接口分策略的让类实现。即比如类A实现接口D和C，类B只实现C，A和B分策略的使用接口


事件调度机制：使用观察者模式，设置被观察者（event），设置观察者（listener），使用事件分配器(dispatcher)绑定观察者与被观察者，最后事件分配器分配事件（dispatch）;可以绑定多个观察者，可以进行相互依赖注入。降低耦合提高内聚



接口与类：
一个接口可以继承多个接口.
interface C extends A, B {}是可以的.

一个类可以实现多个接口:
class D implements A,B,C{}

但是一个类只能继承一个类,不能继承多个类
class B extends A{}

在继承类的同时,也可以继承接口:
class E extends D implements A,B,C{}