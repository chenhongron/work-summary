1、JVM内存管理
   http://blog.csdn.net/yfqnihao
   JVM是参照操作系统设计的
   寄存器区  ：线程专用，记录线程进行的地址，线程的阻塞、恢复、挂起都需要在这里找地址
   栈区      ：局部变量表、操作数栈；最常见的是，比如基本数据类型、对象引用、函数返回地址等
               帧栈，JVM的执行是基于栈的，入机器码入栈执行后出栈
   堆区      ：对象实例以及数组对象等；离程序员最近的内存（重要的是实现了内存管理GC）
   方法区    ：与堆很像，存储运行时常量池、字段信息、方法信息、构造方法、静态变量与普通函数的字节码内容
                   以及一些特殊方法（我们写的代码）
   本地方法栈：用来支持native方法的执行
   内存的回收：线程独有的，线程启动而创建，线程销毁后释放；全局的内存是由GC回收
   JVM执行流程：
     首先，当一个程序启动之前，它的class会被类装载器装入方法区(不好听，其实这个区我喜欢叫做Permanent区)，
     执行引擎读取方法区的字节码自适应解析，边解析就边运行（其中一种方式），
     然后pc寄存器指向了main函数所在位置，虚拟机开始为main函数在java栈中预留一个栈帧（每个方法都对应一个栈帧），
     然后开始跑main函数，main函数里的代码被执行引擎映射成本地操作系统里相应的实现，然后调用本地方法接口，
     本地方法运行的时候，操纵系统会为本地方法分配本地方法栈，用来储存一些临时变量，然后运行本地方法，调用操作系统APIi等等

2、java gc

标记清理算法
  当内存要消耗殆尽时，jvm停止程序运行，gc线程启动，根据roots根查找到可用内存并标记，完成后清理没有标记的，最后开启应用线程继续运行

标记复制算法
  把内存分为使用和闲置两半，当内存要消耗殆尽时，jvm停止程序运行，gc线程启动， 根据roots根查找到可用内存并复制到闲置空间，清理可用空间里的所有内存，闲置和使用内存互转，最后开启应用线程继续运行

标记整理算法
  当内存要消耗殆尽时，jvm停止程序运行，gc线程启动，根据roots根查找到可用内存并标记，完成后清理没有标记的，再整理内存空间，最后开启应用线程继续运行

分代收集算法
  以上3种都有各自的缺点，此时jvm就将内存分为新生（类方法中的局部变量这些）、老年（对象、单例）和永久（String池中的对象，目前元空间后在堆内、类信息）对象，
  新生使用复制算法，申请10%的闲置空间，大于10%的将移动到长期对象这类去，老年和永久使用标记清理或标记整理。
  从JDK8开始已经把永久换移为元空间了，元空间使用本机的内存空间

回收时机
  普通gc只针对新生区域，全局包括长期和永久区域的
  一般要运行很多次普通才会运行一次全局gc

3、垃圾搜集器
    三项最重要指标：
      内存占用、客户端应用、嵌入的项目优先考虑
      吞吐量，一般偏计算数据分析的项目优先考虑
      延迟，一些SLA需要快速响应的项目优先考虑
    类型：
      串行搜集器（serial collector）：它只有一条GC线程，且就像前面说的，它在运行的时候需要暂停用户程序（stop the world）。
      并行搜集器（parallel collector）：它有多条GC线程，且它也需要暂停用户程序（stop the world）。
      并发搜集器（concurrent collector）：它有一条或多条GC线程，且它需要在部分阶段暂停用户程序（stop the world），部分阶段与用户程序并发执行。
    实现：
      G1，开发了近10年才可以商用，不是把内存分成新生、老年代（G1之前如CMS等是新生老年一整块的回收），它提出把内存划分相等的数个region，
      而每个region都可以扮演新生、老年代，从而可以使用不同的收集算法；可以实现一边分配一边回收的高性能，可以设置用户线程停顿时间；
      但内存使用相对CMS高，负载高，小项目上不如CMS快

4、虚拟机规范
   虚拟寄存器、虚拟机栈、本地方法栈都是随线程的开始结束而清空的
   虚拟机堆是必须实现GC的，方法区因为是永久代，随虚拟机的生命周期可以不用实现GC
   主流的HotSpot使用的分代收集算法
   青年、老年、永久代会随着GC的次数增加而转换

5、JVM类加载机制
   类加载器是在虚拟机外实现的；同一加载器加载同一文件才是相等的
   https://www.cnblogs.com/ityouknow/p/5603287.html
   把编译后的字节码加载到内存中的过程
   JVM在预计会使用到之前加载，如果有错并不是立即报出而是在首次使用时报出
   过程：（依次进行，但不是按顺序进行或完成，因为可能在执行前一步的时候穿插后一步）
   加载：把类字节码数据结构放在方法区，在堆区建立基于该类的java.lang.Class数据结构，然后向外提供通过该对象访问方法区的接口
   验证：文件格式验证，元数据验证，字节码验证，符号引用验证（不是必要的）
   准备：分配内存并设置类变量初始值；对同时使用final和static的变量、常量、结构进行初始值放在方法区（hotspot默认放在这），
         其他赋予默认的零值
   解析：把类中的符号引用转换为直接引用
   初始化：变量初始值，包括代码块；只有使用的时候才初始化，把实例类放在堆区
   类加载器：启动类加载器（C++编写，也是JAVA编写，加载lib下的文件）、扩展类加载器（ext下的文件）、应用程序类加载器（自己的）
             其中设计到缓存字节码等
   类的加载：用类去加载另一个类，一般是父类加载
   双亲委派模型：当父类接受到加载任务，不是自己加载而是向上委派，只有它的父类加载失败才会轮到它加载
                         因为同一加载器加载同一文件才是相等的，所以双亲委派保证了应用的稳定性
   自定义类加载器：如果类加密了需要自己加载等

6、内存模型
   分为主内存（物理机中的内存）和工作内存（物理机中的高速缓存）
   线程先把变量从主内存读取到自己的工作内存中操作后再写回主内存
   之间的交互有lock\unlock\read\load\use\assign\store\write 8种操作
   大致分为3种类型去操作，工作内存、主内存、和执行引擎，前两个是存储所以它俩的操作都有个传输过程（read、store）
      执行引擎是直接使用所以只有（use、assign），然后是转换到某个存储（load、write），前两种是给线程锁的（lock\unlock）

7、volatile
   可以保证变量是可见的，即JVM执行引擎读取该变量是会刷新，但它不能保证执行引擎对变量的操作时其他指令是原子性的，所以它不能保证并发
   即对内存模型交互的一个特殊定制，满足，每次执行引擎使用时必须去主内存中加载或写入（保证可见性）
   还可以保证顺序性，即指令重排（保证执行的动作都是依次进行）

8、先行发生原则
   用来判断数据是否存在竞争，线程是 否安全的非常有用的手段
   并发时与时间先后顺序无关

9、线程安全
   基于虚拟机的内存模型去考虑线程是否是原子性、可见性和顺序性的
   安全的：不可变、绝对安全、相对安全、线程兼容、线程对立
   synchronized就是在指令前后加入monitorexit锁，而JAVA线程是一一对应内核线程的，所以synchronized是需要用户态到内核态的切换，是很重的
   CAS比较并交换是一种乐观锁。有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做
   但CAS没有解决ABA问题，即原值被改了回去，但CAS认为它是没被其他线程改过的，要解决ABA问题就使用悲观锁
   还有些自旋锁（不放弃CUP时间片）、锁消除（JVM取消锁）、
      轻量级锁（使用CAS对对象头检查并加减锁达到不用调用操作系统进行互斥量加锁，但是真有竞争时会切换到重重量级加锁，这时比重量级消耗更多）、
      偏向锁（某线程一直占用锁而无其他竞争时后面的线程不在同步了）

10、JVM对代码的优化
   指令重排优化、锁优化（去掉锁、粗粒化等）、缓存

11、其他补充
  只要进行系统调用都需要进行用户态到内核态的切换
  有的虚拟机如Lquidvm把线程的创建直接越过操作系统去与硬件交互，但这个项目终止了
  互斥锁最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成

12、栈、寄存器指令集
   栈指令集基于栈的出入执行时指令多、慢（理论上，因为有优化），但可以自定义空间大；JVM等使用
   寄存器指令集基于物理寄存器执行时指令多、快，但受限于物理机；PHP等使用
   但JAVA JIT编译成汇编指令流后就不会走栈指令集了

13、堆外内存
   在JVM堆上保存堆外内存的地址、大小等信息，然后分配是在堆外，可以不受GC青年代、老年代这些的内存地址变换等，
   这样保证了socket这样的底层的执行效率

