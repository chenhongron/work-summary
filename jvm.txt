1、JVM内存管理
   JVM是参照操作系统设计的
   寄存器区  ：线程专用，记录线程进行的地址，线程的阻塞、恢复、挂起都需要在这里找地址
   栈区      ：局部变量表、操作数栈；最常见的是，比如基本数据类型、对象引用、函数返回地址等
               帧栈，JVM的执行是基于栈的，入机器码入栈执行后出栈
   堆区      ：对象实例以及数组对象等；离程序员最近的内存（重要的是实现了内存管理GC）
   方法区    ：与堆很像，存储运行时常量池、字段信息、方法信息、构造方法、静态变量与普通函数的字节码内容
                   以及一些特殊方法（我们写的代码）
   本地方法栈：用来支持native方法的执行
   内存的回收：线程独有的，线程启动而创建，线程销毁后释放；全局的内存是由GC回收

2、java gc

标记清理算法
  当内存要消耗殆尽时，jvm停止程序运行，gc线程启动，根据roots根查找到可用内存并标记，完成后清理没有标记的，最后开启应用线程继续运行

标记复制算法
  把内存分为使用和闲置两半，当内存要消耗殆尽时，jvm停止程序运行，gc线程启动， 根据roots根查找到可用内存并复制到闲置空间，清理可用空间里的所有内存，闲置和使用内存互转，最后开启应用线程继续运行

标记整理算法
  当内存要消耗殆尽时，jvm停止程序运行，gc线程启动，根据roots根查找到可用内存并标记，完成后清理没有标记的，再整理内存空间，最后开启应用线程继续运行

分代收集算法
  以上3种都有各自的缺点，此时jvm就将内存分为新生（类方法中的局部变量这些）、老年（对象、单例）和永久（String池中的对象，目前元空间后在堆内、类信息）对象，
  新生使用复制算法，申请10%的闲置空间，大于10%的将移动到长期对象这类去，老年和永久使用标记清理或标记整理。
  从JDK8开始已经把永久换移为元空间了，元空间使用本机的内存空间

回收时机
  普通gc只针对新生区域，全局包括长期和永久区域的
  一般要运行很多次普通才会运行一次全局gc

3、垃圾搜集器
    三项最重要指标：
      内存占用、客户端应用、嵌入的项目优先考虑
      吞吐量，一般偏计算数据分析的项目优先考虑
      延迟，一些SLA需要快速响应的项目优先考虑
    类型：
      串行搜集器（serial collector）：它只有一条GC线程，且就像前面说的，它在运行的时候需要暂停用户程序（stop the world）。
      并行搜集器（parallel collector）：它有多条GC线程，且它也需要暂停用户程序（stop the world）。
      并发搜集器（concurrent collector）：它有一条或多条GC线程，且它需要在部分阶段暂停用户程序（stop the world），部分阶段与用户程序并发执行。
    实现：
      G1，开发了近10年才可以商用，不是把内存分成新生、老年代（G1之前如CMS等是新生老年一整块的回收），它提出把内存划分相等的数个region，
      而每个region都可以扮演新生、老年代，从而可以使用不同的收集算法；可以实现一边分配一边回收的高性能，可以设置用户线程停顿时间；
      但内存使用相对CMS高，负载高，小项目上不如CMS快

4、虚拟机规范
   虚拟寄存器、虚拟机栈、本地方法栈都是随线程的开始结束而清空的
   虚拟机堆是必须实现GC的，方法区因为是永久代，随虚拟机的生命周期可以不用实现GC
   主流的HotSpot使用的分代收集算法
   青年、老年、永久代会随着GC的次数增加而转换

5、JVM类加载机制
   类加载器是在虚拟机外实现的；同一加载器加载同一文件才是相等的
   https://www.cnblogs.com/ityouknow/p/5603287.html
   把编译后的字节码加载到内存中的过程
   JVM在预计会使用到之前加载，如果有错并不是立即报出而是在首次使用时报出
   过程：（依次进行，但不是按顺序进行或完成，因为可能在执行前一步的时候穿插后一步）
   加载：把类字节码数据结构放在方法区，在堆区建立基于该类的java.lang.Class数据结构，然后向外提供通过该对象访问方法区的接口
   验证：文件格式验证，元数据验证，字节码验证，符号引用验证（不是必要的）
   准备：分配内存并设置类变量初始值；对同时使用final和static的变量、常量、结构进行初始值放在方法区（hotspot默认放在这），
         其他赋予默认的零值
   解析：把类中的符号引用转换为直接引用
   初始化：变量初始值，包括代码块；只有使用的时候才初始化，把实例类放在堆区
   类加载器：启动类加载器（C++编写，也是JAVA编写，加载lib下的文件）、扩展类加载器（ext下的文件）、应用程序类加载器（自己的）
             其中设计到缓存字节码等
   类的加载：用类去加载另一个类，一般是父类加载
   双亲委派模型：当父类接受到加载任务，不是自己加载而是向上委派，只有它的父类加载失败才会轮到它加载
                         因为同一加载器加载同一文件才是相等的，所以双亲委派保证了应用的稳定性
   自定义类加载器：如果类加密了需要自己加载等

6、内存模型
   分为主内存（物理机中的内存）和工作内存（物理机中的高速缓存）
   线程先把变量从主内存读取到自己的工作内存中操作后再写回主内存
   之间的交互有lock\unlock\read\load\use\assign\store\write 8种操作

7、volatile
   可以保证变量是可见的，即JVM执行引擎读取该变量是会刷新，但它不能保证执行引擎对变量的操作时其他指令是原子性的，所以它不能保证并发
   还可以保证顺序性，即指令重排

8、先行发生原则
   用来判断数据是否存在竞争，线程是 否安全的非常有用的手段
   并发时与时间先后顺序无关

9、线程安全
   基于虚拟机的内存模型去考虑线程是否是原子性、可见性和顺序性的
   安全的：不可变、绝对安全、相对安全、线程兼容、线程对立
   synchronized就是在指令前后加入monitorexit锁，而JAVA线程是一一对应内核线程的，所以synchronized是需要用户态到内核态的切换，是很重的
   CAS比较并交换是一种乐观锁。有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做
   但CAS没有解决ABA问题，即原值被改了回去，但CAS认为它是没被其他线程改过的，要解决ABA问题就使用悲观锁
   还有些自旋锁、锁消除（JVM取消锁）、轻量级锁、偏向锁等

